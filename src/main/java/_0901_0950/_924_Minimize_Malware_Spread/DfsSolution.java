package _0901_0950._924_Minimize_Malware_Spread;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Time Complexity: O(N^2)
 *
 * @author jacka
 * @version 1.0 on 9/20/2020
 */
public final class DfsSolution implements Solution {
  private final Map<Integer, Set<Integer>> ultimateSource = new HashMap<>();

  public int minMalwareSpread(int[][] graph, int[] initial) {
    final int n = graph.length;
    for (final int start : initial) {
      dfs(graph, start, start);
    }
    final int[] singleImpact = new int[n];
    for (final Map.Entry<Integer, Set<Integer>> e : ultimateSource.entrySet()) {
      if (e.getValue().size() == 1) {
        final int init = e.getValue().iterator().next();
        singleImpact[init]++;
      }
    }

    int result = initial[0], maxSingleImpact = singleImpact[result];
    for (int i = 1; i < initial.length; i++) {
      final int init = initial[i];
      if (singleImpact[init] > maxSingleImpact || (singleImpact[init] == maxSingleImpact && init < result)) {
        result = init;
        maxSingleImpact = singleImpact[init];
      }
    }
    return result;
  }

  private void dfs(final int[][] graph, final int start, final int cur) {
    final Set<Integer> curVisited = ultimateSource.getOrDefault(cur, new HashSet<>());
    ultimateSource.put(cur, curVisited);
    if (curVisited.contains(start)) {
      return;
    }
    curVisited.add(start);

    for (int next = 0; next < graph[cur].length; next++) {
      if (graph[cur][next] == 0) continue;
      dfs(graph, start, next);
    }
  }
}
