package _0901_0950._928_Minimize_Malware_Spread_II;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

/**
 * @author zhixi
 * @version 1.0 on 9/21/2020
 */
public final class BfsSolution implements Solution {
  private final Map<Integer, Set<Integer>> directlySource = new HashMap<>();

  public int minMalwareSpread(int[][] graph, int[] initial) {
    final int n = graph.length;
    // infected with passing the initial infected nodes
    final Set<Integer> initialSet = new HashSet<>();
    for (int i : initial) initialSet.add(i);
    for (final int start : initial) {
      final Queue<Integer> q = new ArrayDeque<>() {{
        add(start);
      }};
      while (!q.isEmpty()) {
        final int toRemove = q.remove();
        for (int next = 0; next < n; next++) {
          if (graph[toRemove][next] == 0 || initialSet.contains(next)) continue;
          if (directlySource.computeIfAbsent(next, k -> new HashSet<>()).add(start)) {
            // never visited
            q.add(next);
          }
        }
      }
    } // end of for start;
    final int[] safeNodeFromSource = new int[n];
    for (final var e : directlySource.entrySet()) {
      final Set<Integer> source = e.getValue();
      if (source.size() == 1) {
        safeNodeFromSource[source.iterator().next()]++;
      }
    }

//    System.out.println(Arrays.toString(safeNodeFromSource));
//    System.out.println(directlySource);
    int result = initial[0], max = safeNodeFromSource[result];
    for (int i = 1; i < initial.length; ++i) {
      final int candidate = initial[i];
      if (safeNodeFromSource[candidate] > max || (safeNodeFromSource[candidate] == max && candidate < result)) {
        result = candidate;
        max = safeNodeFromSource[candidate];
      }
    }
    return result;
  }
}
