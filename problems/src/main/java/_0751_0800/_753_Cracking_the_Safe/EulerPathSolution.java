package _0751_0800._753_Cracking_the_Safe;

/**
 * @author jacka
 * @version 1.0 on 1/8/2018.
 */
public class EulerPathSolution {
  final int maxn = 1000000 + 10;
  char[] ans = new char[maxn];//保存最终的结果
  boolean vis[] = new boolean[maxn];//标记边是否被走过

  public void test(final int n) {
    if (n == 1) {
      System.out.println("0123456789");
    }

    int mod = 1, end = 1;
    for (int i = 1; i <= n; i++) {
      mod *= 10;
      end *= 10;
    }
    mod /= 10;
    end += n - 1;
    for (int i = 0; i < n; i++) {
      ans[i] = '0';
    }
    vis[0] = true;
    int now = 0;//now表示的是当前所处的节点状态(即由n-1位数位构成的整数)
    int i = 0, pos = n;
    while (pos < end) {
      now %= mod;
      for (; i < 10; i++) {
        if (!vis[now * 10 + i])//当前状态节点还有没有走过的边
        {
          vis[now * 10 + i] = true;
          ans[pos++] = (char) (i + '0');
          now = now * 10 + i;
          i = 0;
          break;
        }
      }
      if (i == 10 && pos < end)//当前递归层走不通了(即我们进入了一个不存在没走过边的节点),且还没有走完所有的边
      {
        pos--;
        now = (ans[pos - n + 1] - '0') * mod + now;
        vis[now] = false;//消除死胡同的标记,因为如果直接在当前状态走边now的话,会进死胡同,所以回退
        i = now % 10 + 1;
        now /= 10;
      }
    }
    ans[end] = '\0';

    System.out.printf("%s\n", String.valueOf(ans).substring(0, end)); //注意:如果此处ans是int输出,
    // 一个个的输出每个数字的话,时间从79ms->489m
  }

  public static void main(String[] args) {
    final String s =
        "000100200300400500600700800901101201301401501601701801902102202302402502602702802903103203303403503603703803904104204304404504604704804905105205305405505605705805906106206306406506606706806907107207307407507607707807908108208308408508608708808909109209309409509609709809911121131141151161171181191221231241251261271281291321331341351361371381391421431441451461471481491521531541551561571581591621631641651661671681691721731741751761771781791821831841851861871881891921931941951961971981992223224225226227228229233234235236237238239243244245246247248249253254255256257258259263264265266267268269273274275276277278279283284285286287288289293294295296297298299333433533633733833934434534634734834935435535635735835936436536636736836937437537637737837938438538638738838939439539639739839944454464474484494554564574584594654664674684694754764774784794854864874884894954964974984995556557558559566567568569576577578579586587588589596597598599666766866967767867968768868969769869977787797887897987998889899900";
    System.out.println(s.length());

    new EulerPathSolution().test(2);
  }
}
