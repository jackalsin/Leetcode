package _0101_0150._123_Best_Time_to_Buy_and_Sell_Stock_III;

/**
 * @author jacka
 * @version 1.0 on 6/25/2017.
 */
public class Solution {
  public int maxProfit(int[] prices) {
//    return dpSolution(prices);
    return maxProfitKTransactionsSimplified(prices, 2);
  }

  /**
   * This solution is not simplified bue well explained.
   * <p>
   * Denote T[i][j] the ith transaction on jth day
   * Max can be generated by the following 2 scenarios:
   * 1) Do no transaction on jth day: T[i][j - 1]
   * 2) Do one transaction on jth day:
   * which means I have to sell on jth day and buy them on 0 ~ m - 1 day.
   * max of {@expression prices[j] - prices[m] + T[i - 1][m], m belongs to [0, j - 1]}
   * {The part above is {@variable tempMax}}
   * {@expression prices[j] - prices[m]} the profit of i th transaction
   * {@expression T[i - 1][m]} until that day, the profit that after
   * (i - 1) times of transactions
   * reference: https://www.youtube.com/watch?v=oDhu5uGq_ic
   *
   * @param prices
   * @return
   */
  private int maxProfitKTransactions(int[] prices, final int K) {
    if (prices.length == 0) return 0;
    int[][] maxProfit = new int[K + 1][prices.length];
    for (int k = 1; k <= K; k++) {
      int tmpMax = maxProfit[k - 1][0] - prices[0]; // expression when m = 0
      for (int j = 1; j < prices.length; j++) {
        maxProfit[k][j] = Math.max(maxProfit[k][j - 1], prices[j] + tmpMax);
        tmpMax = Math.max(tmpMax, maxProfit[k - 1][j] - prices[j]);
      }
    }
    return maxProfit[K][prices.length - 1];
  }

  private int maxProfitKTransactionsSimplified(int[] prices, final int K) {
    if (prices.length == 0) return 0;
    int[] maxProfit = new int[prices.length];
    for (int i = 1; i <= K; i++) {
      int tempMax = maxProfit[0] - prices[0];
      for (int j = 1; j < prices.length; j++) {
        int prevMaxProfit = maxProfit[j];
        maxProfit[j] = Math.max(maxProfit[j - 1], prices[j] + tempMax);
        tempMax = Math.max(tempMax, prevMaxProfit - prices[j]);
      }
    }
    return maxProfit[prices.length - 1];
  }

  private int dpSolution(int[] prices) {
    if (prices.length <= 1) {
      return 0;
    } else {
      final int K = 2;
      int maxProf = 0;
      int[][] dp = new int[K + 1][prices.length];
      for (int kk = 1; kk <= K; kk++) {
        int tmpMax = dp[kk - 1][0] - prices[0];
        for (int ii = 1; ii < prices.length; ii++) {
          dp[kk][ii] = Math.max(dp[kk][ii - 1], prices[ii] + tmpMax);
          tmpMax = Math.max(tmpMax, dp[kk - 1][ii] - prices[ii]);
          maxProf = Math.max(dp[kk][ii], maxProf);
        }
      }
      return maxProf;
    }
  }
}
